from fastapi import FastAPI, HTTPException, status
import requests
import json
import time
import logging
from pydantic import BaseModel

app = FastAPI()

class CPERequest(BaseModel):
    cpe: str
    sender: str
    recipient: str
    product_id: str


@app.get('/')
def func():
    return {'hello':'api is working'}

@app.post('/getsbom')
async def Get_sbom_data(request: CPERequest):
    """
    Endpoint to receive a message from the Buyer API and route it to the Vendor API.

    Args:
        request (RouteMessageRequest): The request containing sender, recipient, and product_id.

    Returns:
        dict: JSON response from the Vendor API.
    """
    try:
        # Route the message to the Vendor API running on localhost:8081
        vendor_api_url = "http://localhost:8081/provide_sbom/"
        response = requests.get(vendor_api_url, params={"product_id": request.product_id})
        # Check for errors in response from Vendor API
        response.raise_for_status()
        return response.json()

    except requests.RequestException as e:
        raise HTTPException(status_code=500, detail=f"Error communicating with Vendor API: {str(e)}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/getVulenrability")
def read_item(request: CPERequest):
    try:
        response = main(request.cpe)
        return response
        
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error"
        )



# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def log_interaction(interaction_data): 
    logging.info(f"{interaction_data}")

def get_vulnerabilities_from_nvd(cpe_name):
    """Query the NVD API for vulnerabilities using CPE name."""
    url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName={cpe_name}"
   

    try:
        log_interaction(f'Creating requestion to get vulnerabilities for {cpe_name}')
       
        response = requests.get(url)
        response.raise_for_status()  # Raise an HTTPError for bad responses
        # with open(f'{name}.json', 'w') as json_file:
        #     json.dump(response.json(), json_file, indent=4)  # indent=4 for pretty printing
        # print(f"Data saved to {name}.json")
        print('GetVulnerabilities exicution completed')
        return response.json().get('vulnerabilities', [])
    except requests.RequestException as e:
        # logging.error(f"Error fetching data from NVD: {e}")
        print('error in get_vulnerabilities_from_nvd', e)
        return []
    

def check_vulnerabilities(cpe):
    """Check the SBOM dependencies for known vulnerabilities."""

        
    # for component in sbom.get('components',[]):
        # cpe_name = component.get('cpe','')
        # print(component.get('name'))
    vulnerabilities_info = {}
    logging.info(f"Checking vulnerabilities for {cpe}...")
    cve_list = get_vulnerabilities_from_nvd(cpe)
    time.sleep(1)  # Rate limit to avoid hitting API limits
    vulnerabilities = cve_list
    vulnerabilities_info['vulnerabilities'] = []
    for vulnerabilitie in vulnerabilities:
        cve_info = vulnerabilitie.get('cve', {})
        cve_id = cve_info.get('id', 'Unknown')
        cve_description = cve_info.get('descriptions', [{}])[0].get('value', 'No description available')
        metrics = cve_info.get('metrics', {})
        cvss_metric_v2 = metrics.get('cvssMetricV2', metrics.get('cvssMetricV31',[{}]))[0]
        cvss_score = cvss_metric_v2.get('cvssData', {}).get('baseScore', 'N/A')
        baseSeverity = cvss_metric_v2.get('baseSeverity')
        cve_exploitabilityScore = cvss_metric_v2.get('exploitabilityScore')
        cve_impactScore = cvss_metric_v2.get('impactScore')
        vulnerabilities_info['vulnerabilities'].append({
            'CVE ID': cve_id,
            'Description': cve_description,
            'CVSS Score': cvss_score,
            'cve_impactScore':cve_impactScore,
            'cve_exploitabilityScore':cve_exploitabilityScore,
            'baseSeverity':baseSeverity
        })
        
       


    return vulnerabilities_info



def main(cpe):
  
    vulnerabilities = check_vulnerabilities(cpe)
    return vulnerabilities
    